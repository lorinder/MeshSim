#!/usr/bin/env python3

import sys
import os
import shutil

tool_dir = os.path.dirname(os.path.realpath(__file__))
sys.path.append(tool_dir + os.sep + "modules")

import genconf

def gen_mk_header(fp_mk):
    fp_mk.write("# Makefile automatically generated by stagesim\n\n"
           + ".PHONY: all clean\n"
           + "all:\n"
           + "\n"
           + "MESH_SIM=./mesh_sim\n"
           + "\n")

def gen_mk_target_and_conf(fp_mk, index, kv, conf_in_dir, target_dir):
    """Generate a target for a set of parameters.

    @param  fp_mk
            file object of the Makefile.

    @param  index
            numeric index of the simulation run.  (Used to generate the
            output filename of the simulation run.)

    @param  kv
            set of parameter values for this target

    @param  conf_in_dir
            location of the conf.in directory to deduce configuration
            from.

    @param  target_dir
            the target directory for all the simulation outputs.
    """

    # We wrap the name with commas on both ends to make it easier to extract
    # keys and values from the name with regular expressions. For
    # example, the regular expression ,example_([^,]*), will then match
    # the parameter/variable example, and the parenthesis subexpression
    # its value.
    outdir = "run%sparams_%05d" % (os.sep, index)

    # Create the directories
    os.makedirs(os.sep.join([target_dir, outdir, 'conf']), exist_ok=True)
    conf_dir = os.sep.join([outdir, 'conf'])
    
    # Create the configuration
    genconf.apply_template(conf_in_dir,
                        os.sep.join([target_dir, conf_dir]),
                        kv)

    # Create params file in outdir
    fp = open(os.sep.join([target_dir, outdir, "params.txt"]), 'w')
    for (k, v) in sorted(kv.items()):
        fp.write("%-15s %s\n" % (k, v))
    fp.close()
    
    # Create makefile rules
    fp_mk.write("%s/done_sim:\n" % (outdir,))
    fp_mk.write(("\t/usr/bin/time -v ${MESH_SIM} `cat \"%s/cmdline_args.txt\"` "
                + "\"%s\" \"%s\" > \"%s/stdout.txt\" 2> \"%s/stderr.txt\"\n")
                % (conf_dir, conf_dir, outdir, outdir, outdir))
    fp_mk.write(("\tif find \"%s\"/*.pcap -maxdepth 0 >/dev/null 2>&1 ; then "
      + "gzip \"%s\"/*.pcap ; fi\n") % (outdir, outdir,))
    fp_mk.write("\tdate > \"%s/done_sim\"\n" % (outdir,))
    fp_mk.write("all: %s/done_sim\n" % (outdir,))
    fp_mk.write(".PHONY: clean_%s\n" % (outdir,))
    fp_mk.write("clean_%s:\n" % (outdir,))
    fp_mk.write("\trm -f \"%s/done_sim\"\n" % (outdir,))
    fp_mk.write("\trm -f \"%s\"/*.pcap.gz\n" % (outdir,))
    fp_mk.write("clean: clean_%s\n" % (outdir,))
    fp_mk.write("\n")
    return True

def usage():
    print("Creates a stage for a set of simulations")
    print("")
    print("stagesim creates a directory populated with the necessary")
    print("content to execute a set of simulation and record outcomes.")
    print("The directory will in particular contain the Makefile to")
    print("execute simulation commands, as a prepopulated run/ directory.")
    print("")
    print("conf.in and enum files are also placed in the directory;")
    print("they are not strictly necessary to run simulations but are")
    print("useful for future reference.")
    print("")
    print("usage: stagesim -h | -d <stage-dir> -e <enum-file> [ -i <conf-in-dir> ]")
    print("")
    print("  -h             display this help and exit")
    print("  -d <stage-dir> location of stage directory to be created")
    print("  -e <enum-file> JSON enumerator expression file name (see report)")
    print("  -i <conf-in>   location of conf.in directory [default: conf.in]")

if __name__ == "__main__":
    import getopt
    import json
    import stat
    import shlex

    import enumerators

    # default values
    dirname = None
    enum_str = None
    indir = 'conf.in'

    # scan command line arguments
    opts, args = getopt.getopt(sys.argv[1:], "hd:e:i:")
    for o, v in opts:
        if o == '-h':
            usage()
            sys.exit(0)
        elif o == '-d':
            dirname = v
        elif o == '-e':
            enum_str = v
        elif o == '-i':
            indir = v
    if dirname is None:
        sys.stderr.write("Error:  Missing stage dir name (-d).\n")
        sys.exit(1)
    if enum_str is None or len(enum_str) == 0:
        sys.stderr.write("Error:  Missing enumeration file name (-e).\n")
        sys.exit(1)
    if enum_str[0] == '{':
        enum_dict = json.loads(enum_str)
    else:
        enum_dict = json.load(open(enum_str, 'r'))
    enum_gen = enumerators.get_enumerator_from_dict(enum_dict)

    # Create the output directory
    try:
        os.mkdir(dirname)
    except OSError as e:
        sys.stderr.write("Error:  Cannot create staging dir: %s\n" \
                        % (str(e),))
        sys.exit(1)

    # Create the enum.json
    fp = open(dirname + os.sep + "enum.json", 'w')
    json.dump(enum_dict, fp, indent=2, sort_keys=True)
    fp.close()

    # Copy the conf.in
    shutil.copytree(indir, dirname + os.sep + "conf.in")

    # Generate the Makefile
    fp_mk = open(dirname + os.sep + "Makefile", 'w')
    gen_mk_header(fp_mk)
    for i, kv in enumerate(enum_gen):
        gen_mk_target_and_conf(fp_mk,       # fd of Makefile
                               i,           # simulation index
                               kv,          # parameter values
                               dirname + os.sep + "conf.in", # conf.in
                               dirname)     # parent target dir
    fp_mk.close()
